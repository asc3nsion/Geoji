<!-- 
This is an element button used as a base for other buttons.
 text = The text to be displayed on the button
 icon = The icon to be desplayed on the button
 iput = This is the id of the component the button will call a method on.

 style of the button is set via j-styles behavior.
 interaction is set via j-handler.
 if the button doesn't have an explicit id, one is assigned via auto-id.
-->
<!-- components: -->
<link rel="import" href="../../bower_components/polymer/polymer.html">
<!-- behaviors: -->
<link rel="import" href="../../behaviors/style/j-styles.html">
<link rel="import" href="../../behaviors/interaction/j-handler.html">
<link rel="import" href="../../behaviors/interaction/j-events.html">
<link rel="import" href="../../behaviors/selection/auto-id.html">
<link rel="import" href="../../behaviors/crypto/j-encrypt.html">
<link rel="import" href="../../behaviors/crypto/j-decrypt.html">
<link rel="import" href="../../behaviors/util/j-util.html">
<style>

paper-card.editor{
    width: 100%;
}

google-map {
    height: 40vh;
    width: 95%;
}

paper-icon-button.createMarker #icon {
    left: 2vw;
    padding: 5px;
    width: 100%;
    height: 100%;
}

paper-icon-button.createMarker {
    width: 20%;
    height: 8vh;
}

iron-icon.createMarker {
    margin: 0px 0px 0px 22%;
    width: 55%;
    height: 10%;
}

iron-image.createMarker {
    margin: auto;
    max-width: 100%;
    max-height: 100%
}

input.createMarker {
    margin: 1% 0;
    bottom: 10%;
    width: 40%;
}

input.vidInput {
    margin: 1% 0;
    bottom: 10%;
    width: 30%;
}

paper-button.saveGeoji {
    float: right;
    margin: 2% 0 10px 10px;
    position: relative;
}

gold-email-input.createMarker {
    background-color: orange;
    color: red;
    width: 85%;
    margin: 10px 10px 10px 10px;
}

paper-input-container.createMarker {
    width: 30%;
    left: 3%;
    display: inline-block;
}

paper-input-container.createMarkerData {
    width: 85%;
    margin: 10px 10px 10px 10px;
}

paper-input-container.txtData {
    margin: auto;
    background-color: #EBF0B1;
    width: 80%;
}

paper-dialog.txtData {
    width: 100vw;
    height: 75vh;
    max-height: 350px;
    min-height: 200px;
    max-width: 400px;
    min-width: 100px;
    
}

paper-button.txtData {
    width: 25%;
    height: 5%;
    max-height: 80px;
    min-height: 50px;
    max-width: 300px;
    min-width: 100px;
    float: right;
    margin: 3% 1% 1% 1%;
    font-size: 100%;
}

text-area.txtData {
    width: 75vw;
    height: 50%;
    max-height: 500px;
    min-height: 150px;
    max-width: 300px;
    min-width: 100px;
    font-size: 25%;
}

div.anonymousData {
    width: 5%;
    height: 5%;
    max-height: 200px;
    min-height: 50px;
    max-width: 200px;
    min-width: 50px;
    font-size: 75%;
}

paper-dialog.decryptData {
    width: 45vw;
    height: 25%;
}

paper-dialog.imgData {
    width: 100vw;
    max-width: 500px;
    min-width: 100px;
    font-size: 1.8vw;
    display:block;
    overflow:auto;
}

paper-dialog.datePicker {
    width: 75%;
    max-width: 600px;
    min-width: 50px;
    font-size: 1vw;
    position: absolute;
    left: 0%;
}

paper-dialog.timePicker {
    width: 85%;
    max-width: 600px;
    min-width: 50px;
    font-size: 1vw;
    margin: 0 auto;
    padding: 0px;
}

paper-dialog.vidData {
    width: 100vw;
    max-height: 90%;
    min-height: 70%;
    max-width: 400px;
    min-width: 100px;
    font-size: 1.8vw;
}

paper-card.emailList {
    display: inline-block;
}

paper-spinner-lite.saveSpinner {
    width: 300px;
    height: 300px;
    --paper-spinner-stroke-width: 10px;
    margin: auto;
}

paper-progress.bar {
    margin: auto;
    width: 80%;
}

paper-card.emailList {
    margin-top: 9vh;
    height: 100%;
    max-width: 100%;
    display: inline-block;
    font-size: 50%;
    z-index: :0;
}

paper-menu.editor {
    width: 28%;
    display: inline-block;
    z-index: 100;

}

div.dateTimes{
    zoom: 0.9;
    -moz-transform: scale(0.9);
}

dev.errorHolder{
    width: 100%;
    margin-top:3px;
}
iron-icon.detail{
    width: 4vw;

}
iron-icon input, .pass{
    color: green;
}
iron-icon input, .fail{
    color: red;
}
paper-fab.pass{
    --paper-fab-background : green;
}
paper-fab.fail{
    --paper-fab-background : red;
}

p.invalidError{
    zoom: 0.7;
    -moz-transform: scale(0.7);
}
</style>
<dom-module id="geoji-editor">
    <template>
        <firebase-auth id="{{assignCtrl('publicAuth')}}" location="https://geoji.firebaseio.com/public"></firebase-auth>
        <firebase-collection id="{{assignCtrl('geojiPublic')}}" limit-to-first="100" location="https://geoji.firebaseio.com/public/" data="{{publicData}}" </firebase-collection>
            <firebase-auth id="{{assignCtrl('privateAuth')}}" location="https://geoji.firebaseio.com/private"></firebase-auth>
            <firebase-collection id="{{assignCtrl('geojiPrivate')}}" limit-to-first="3" location="https://geoji.firebaseio.com/private/" data="{{privateData}}" limitToFirst="100">
            </firebase-collection>
            <firebase-auth id="{{assignCtrl('mineAuth')}}"></firebase-auth>
            <firebase-collection id="{{assignCtrl('geojiMine')}}" limit-to-first="3" limitToFirst="100">
            </firebase-collection>
            <paper-card id="{{assignCtrl('geojiCard')}}" heading="" image="{{cardImage}}" class="relative editor">
                <div class="errorHolder"><p></p></div>
                <paper-input-container id="{{assignCtrl('titleContainer')}}" class="createMarker absolute z100">
                    <paper-tooltip>Enter the Geoji Title</paper-tooltip>
                    <iron-icon id="{{assignCtrl('titleIcon')}}" icon="icons:add-circle-outline" class="inlineBlock z100 detail"></iron-icon>
                    <label id="{{assignLabel('title')}}" for="title">Title</label>
                    <input id="{{labeledCtrl('title')}}" type="text" autofocus="true" class="createMarker absolute z100" is="iron-input" bind-value="{{title}}">
                    <paper-icon-button suffix icon="clear"></paper-icon-button>
                </paper-input-container>
                <paper-menu class="editor left35pct absolute z100">
                    <paper-submenu>
                        <paper-item class="menu-trigger">
                            <paper-tooltip>Enter Date and Time information</paper-tooltip>
                            <iron-icon suffix id="{{assignCtrl('dateIcon')}}" icon="icons:alarm-add" class="z100 detail"></iron-icon>
                            <paper-icon-button suffix icon="arrow-drop-down-circle" class="z100"></paper-icon-button>
                        </paper-item>
                        <paper-menu class="menu-content">
                            <paper-item>
                                <paper-input-container class="inlineOneHalf">
                                    <iron-icon suffix icon="icons:date-range" class="detail"></iron-icon>
                                    <paper-input-container id="{{assignCtrl('dateInput')}}">
                                        <label id="{{assignLabel('date')}}" for="date">Start Date</label>
                                        <input id="{{labeledCtrl('date')}}" type="text" class="inlineOneHalf" is="iron-input" bind-value="{{date}}">
                                    </paper-input-container>
                                    <paper-icon-button suffix icon="icons:forward" on-tap="setDate"></paper-icon-button>
                                </paper-input-container>
                            </paper-item>
                            <paper-item>
                                <paper-input-container class="inlineOneHalf">
                                    <iron-icon suffix icon="icons:date-range"></iron-icon>
                                    <paper-input-container id="{{assignCtrl('endInput')}}">
                                        <label id="{{assignLabel('end')}}" for="end">End Date</label>
                                        <input id="{{labeledCtrl('end')}}" type="text" class="inlineOneHalf" is="iron-input" bind-value="{{end}}">
                                    </paper-input-container>
                                    <paper-icon-button suffix icon="icons:eject" on-tap="setEnd"></paper-icon-button>
                                </paper-input-container>
                            </paper-item>
                            <paper-item>
                                <paper-input-container class="inlineOneHalf">
                                    <iron-icon suffix icon="icons:query-builder"></iron-icon>
                                    <paper-input-container id="{{assignCtrl('startTimeInput')}}">
                                        <label id="{{assignLabel('startTime')}}" for="startTime">Start Time</label>
                                        <input id="{{labeledCtrl('startTime')}}" type="text" class="inlineOneHalf" is="iron-input" bind-value="{{startTime}}">
                                    </paper-input-container>
                                    <paper-icon-button suffix icon="icons:forward" on-tap="setStartTime"></paper-icon-button>
                                </paper-input-container>
                            </paper-item>
                            <paper-item>
                                <paper-input-container class="inlineOneHalf">
                                    <iron-icon suffix icon="icons:query-builder"></iron-icon>
                                    <paper-input-container id="{{assignCtrl('endTimeInput')}}">
                                        <label id="{{assignLabel('endTime')}}" for="endTIme">End Time</label>
                                        <input id="{{labeledCtrl('endTime')}}" type="text" class="inlineOneHalf" is="iron-input" bind-value="{{endTime}}">
                                    </paper-input-container>
                                    <paper-icon-button suffix icon="icons:eject" on-tap="setEndTime"></paper-icon-button>
                                </paper-input-container>
                            </paper-item>
                        </paper-menu>
                    </paper-submenu>
                </paper-menu>
                <paper-menu class="editor left60pct absolute" data-tip="This is the text of the tooltip2">
                    <paper-submenu>
                        <paper-item class="menu-trigger">
                            <paper-tooltip>Check this make Geoji Anonymous</paper-tooltip>
                            <iron-icon suffix icon="icons:block" class="detail"></iron-icon>
                            <paper-checkbox id="{{assignCtrl('includeProfile')}}" checked="{{anonymous}}"></paper-checkbox>
                        </paper-item>
                    </paper-submenu>
                </paper-menu>
                <div class="card-content absolute">
                    <div id="{{assignCtrl('containerPrivate')}}" class="editor margin-top80px">
                        <paper-tooltip>Invite users to this Geoji</paper-tooltip>
                        <iron-icon id="{{assignCtrl('publicIcon')}}" icon="icons:mail" class="inlineBlock detail"></iron-icon>
                        <paper-toggle-button id="{{assignCtrl('public')}}" checked="{{private}}" class="margin-left3pct inlineBlock">Users</paper-toggle-button>
                        <paper-input-container id="{{assignCtrl('email')}}" class="createMarkerData" bind-value="{{emailValue}}" hidden="true">
                            <label id="{{assignLabel('emailInput')}}" for="emailInput">Email Invite</label>
                            <input id="{{labeledCtrl('emailInput')}}" autocomplete="on" type="email" is="iron-input" type="email" autocomplete="on" bind-value="">
                            <span class="space"></span>
                            <paper-input-error><p class="invalidError margin-top30px">Enter a valid email!</p></paper-input-error>
                            <paper-icon-button suffix icon="add" on-tap="addEmail"></paper-icon-button>
                        </paper-input-container>
                    </div>
                    <div id="{{assignCtrl('containerEncrypt')}}" class="editor margin-top80px">
                        <paper-tooltip>Encrypt data of this Geoji</paper-tooltip>
                        <iron-icon id="{{assignCtrl('encryptIcon')}}" icon="icons:https" class="inlineBlock detail"></iron-icon>
                        <paper-toggle-button id="{{assignCtrl('encrypt')}}" checked="{{encrypted}}" class="inlineBlock">Encrypt</paper-toggle-button>
                        <paper-input-container id="{{assignCtrl('cipher')}}" class="createMarkerData" bind-value="{{emailValue}}" hidden="true">
                            <label id="{{assignLabel('cipherInput')}}" for="cipherInput">Enter Cipher</label>
                            <input id="{{labeledCtrl('cipherInput')}}" type="text" is="iron-input" bind-value="{{cipherKey}}" class="z300">
                            <input id="cipherHidden" is="iron-input" type="text" bind-value="{{cipherKey}}" hidden="true">
                            <span class="space"></span>
                            <paper-input-error><p class="invalidError">8 characters, 1 number, 1 symbol</p></paper-input-error>
                            <paper-icon-button suffix icon="autorenew" on-tap="createcipher"></paper-icon-button>
                            <paper-icon-button id="{{assignCtrl('cipherCopy')}}" suffix icon="content-copy" on-tap="copycipher" class="cut" data-clipboard-action="copy" data-clipboard-target="#cipherHidden" hidden="true"></paper-icon-button>
                        </paper-input-container>
                    </div>
                    <paper-card id="{{assignCtrl('list')}}" class="emailList">{{emailString}}</paper-card>
                </div>
                <google-map map="{{map}}" id="{{assignCtrl('map')}}" latitude="{{currentLatitude}}" longitude="{{currentLongitude}}" min-zoom="9" max-zoom="30" language="en" api-key="AIzaSyCgmlzQ8iH-U2KDt2mhXJbZvQm-KB5dWSo" clickEvents="true" google-map-dblclick="placeMarker" fitToMarkers="true" zoom="20" drag-events="true">
                    <input id="{{assignCtrl('search')}}" autocomplete="true" type="text" list="addressList" placeholder="Search by name" class="bottomLeftCorner margin1pct" value="{{query::input}}">
                    <google-map-marker id="{{assignCtrl('targetMarker')}}" name="targetMarker" latitude="{{currentLatitude}}" longitude="{{currentLongitude}}" draggable="true" drag-events="true" click-events="true" icon="/images/marker-target.png"><paper-tooltip>your current location</paper-tooltip></google-map-marker>
                    <paper-icon-button class="topCorner margin1pct" icon="autorenew" on-tap="refreshMap" style="background:white;"><paper-tooltip>Refresh Map</paper-tooltip></paper-icon-button>
                    <datalist id="addressList">
                        <template is="dom-repeat" items="{{mapResult}}" as="result">
                            <option data-value="{{result.name}}">{{result.name}} {{result.formatted_address}}</option>
                        </template>
                    </datalist>
                </google-map>
                <div class="card-actions">
                    <label id="{{assignLabel('txtMarkerBtn')}}" for="txtMarkerBtn" name="text Marker button" style="display:none">Create a Text Marker</label>
                    <paper-icon-button id="{{labeledCtrl('txtMarkerBtn')}}" on-tap="txtMarker" icon="geoji-icons:mascot-txt" class="createMarker">
                        <paper-tooltip>Create a text marker</paper-tooltip>
                    </paper-icon-button>
                    <label id="{{assignLabel('imgMarkerBtn')}}" for="imgMarkerBtn" style="display:none">Create an Image Marker</label>
                    <paper-icon-button id="{{labeledCtrl('imgMarkerBtn')}}" on-tap="imgMarker" icon="geoji-icons:mascot-img" class="createMarker">
                        <paper-tooltip>Create an imaget marker</paper-tooltip>
                    </paper-icon-button>
                    <label id="{{assignLabel('vidMarkerBtn')}}" for="vidMarkerBtn" style="display:none">Create an Image Marker</label>
                    <paper-icon-button id="{{labeledCtrl('vidMarkerBtn')}}" on-tap="vidMarker" icon="geoji-icons:mascot-vid" class="createMarker">
                        <paper-tooltip>Create a video marker</paper-tooltip>
                    </paper-icon-button>
                    <paper-button id="{{assignCtrl('add')}}" class="saveGeoji" raised on-tap="addGeoji" disabled="{{invalid}}">
                        <paper-tooltip>Save the Geoji</paper-tooltip>
                        ADD
                    </paper-button>
                    <paper-button id="{{assignCtrl('save')}}" class="saveGeoji" raised on-tap="saveGeoji" hidden="true">
                        <paper-tooltip>Save the Geoji</paper-tooltip>
                        SAVE
                    </paper-button>
                </div>
            </paper-card>
            <paper-dialog class="txtData z1000" id="{{assignCtrl('txtDialog')}}" modal role="alertdialog">
                <h2>Geoji Message</h2>
                <paper-icon-button suffix class="closeDialog" icon="clear" on-tap=""></paper-icon-button>
                <paper-input-container id="{{assignCtrl('txtContainer')}}" type="text" class="txtData" bind-value="">
                    <textarea id="{{assignCtrl('txtInput')}}" class="txtData" rows="5" cols="15"></textarea>
                </paper-input-container>
                <paper-button id="{{assignCtrl('cancelTxt')}}" class="txtData theme" raised on-tap="toggleTxtDialog">CANCEL</paper-button>
                <paper-button id="{{assignCtrl('saveTxt')}}" class="txtData theme" raised on-tap="saveTxt">SAVE</paper-button>
            </paper-dialog>
            <paper-dialog class="imgData z1000" id="{{assignCtrl('imgDialog')}}" modal role="alertdialog">
                <h2 class="inlineBlock">Geoji Image</h2>
                <paper-toggle-button id="{{assignCtrl('coverImg')}}" checked="{{coverSet}}" class="inlineBlock">Cover Image</paper-toggle-button>
                <paper-spinner-lite id="{{assignCtrl('imgSpinner')}}" class="orange createMarker"></paper-spinner-lite>
                <div id="{{assignCtrl('tempImgs')}}">
                    <iron-icon id="{{assignCtrl('imgIcon')}}" icon="geoji-icons:mascot-img-icon" class="createMarker"></iron-icon>
                </div>
                <j-img-process id="{{assignCtrl('imgProcess')}}" imgur="true" fixed="true" fixedSize="200" width="200" height="200" hideButtons="false" handleDialog="{{getCtrlId('imgDialog')}}" parentElement="{{getCtrlId('imgDialog')}}"></j-img-process>
            </paper-dialog>
            <paper-dialog class="vidData z1000" id="{{assignCtrl('vidDialog')}}" modal role="alertdialog">
                <paper-progress class="bar" id="{{assignCtrl('vidProgress')}}"></paper-progress>
                <paper-progress class="bar" id="{{assignCtrl('vidPocessProgress')}}"></paper-progress>
                <h2 class="inlineBlock">Geoji Video</h2>
                <paper-spinner-lite id="{{assignCtrl('vidSpinner')}}" class="orange inlineBlock"></paper-spinner-lite>
                <paper-input-container id="{{assignCtrl('vidTitle')}}" class="vidInput" bind-value="{{vidTitle}}">
                    <label for="{{assignLabel('vidTitleInput')}}">Title</label>
                    <input id="{{labeledCtrl('vidTitleInput')}}" type="text" is="iron-input" bind-value="">
                </paper-input-container>
                <paper-input-container id="{{assignCtrl('vidUrl')}}" class="vidInput unselectable" bind-value="{{vidTitle}}">
                    <label for="{{assignLabel('vidUrlInput')}}">Link</label>
                    <input id="{{labeledCtrl('vidUrlInput')}}" type="text" is="iron-input" bind-value="{{vidUrl}}">
                </paper-input-container>
                <div id="{{assignCtrl('vidImgs')}}">
                    <iron-icon id="{{assignCtrl('vidIcon')}}" icon="geoji-icons:mascot-img-icon" class="createMarker"></iron-icon>
                </div>
                <google-youtube id="{{assignCtrl('youtubePlayer')}}" video-id="{{vidId}}" height="270px" width="100%" rel="0" autoplay="0" hidden="true"></google-youtube>
                <j-vid-process id="{{assignCtrl('vidProcess')}}" title="{{vidTitle}}" auto="true" privacyStatus="unlisted" categoryId="22" videoUrl="{{vidUrl}}"></j-vid-process>
            </paper-dialog>
            <paper-dialog class="vidData z1000" id="{{assignCtrl('saveDialog')}}" modal role="alertdialog">
                <h2>Saving Geoji</h2>
                <paper-progress class="bar" id="{{assignCtrl('encryptProgress')}}"></paper-progress>
                <paper-spinner-lite id="{{assignCtrl('saveSpinner')}}" class="orange createMarker saveSpinner center"></paper-spinner-lite>
            </paper-dialog>
            <paper-dialog class="decryptData z1000" id="{{assignCtrl('cipherDialog')}}" modal role="alertdialog">
                <paper-progress class="bar" id="{{assignCtrl('decryptProgress')}}"></paper-progress>
                <h2>Enter Cipher Key<paper-spinner-lite id="{{assignCtrl('decryptSpinner')}}"  class="center"></paper-spinner-lite></h2>
                <paper-input-container id="{{assignCtrl('decryptContainer')}}" class="txtData" bind-value="">
                    <paper-tooltip>Enter Cipher Key: At least 8 characters, 1 number and 1 symbol</paper-tooltip>
                    <label for="{{assignLabel('decryptInput')}}">Link</label>
                    <input id="{{labeledCtrl('decryptInput')}}" is="iron-input" type="text" class="txtData" bind-value="{{cipherKey}}"></input>
                </paper-input-container>
                <paper-button id="{{assignCtrl('cancelDecryptBtn')}}" class="txtData theme" raised on-tap="toggleDecryptDialog">CANCEL</paper-button>
                <paper-button id="{{assignCtrl('decryptBtn')}}" class="txtData theme" raised on-tap="_decryptGeoji">DECRYPT</paper-button>
            </paper-dialog>
            <div class="dateTimes">
                <paper-dialog class="timePicker z1000" id="{{assignCtrl('dateDialog')}}" modal role="alertdialog">
                <h2>Start</h2>
                    <paper-card class="center">
                        <div class="topCorner">
                            <paper-icon-button suffix class="closeDialog" icon="clear" on-tap="closeDate" class="topCorner"></paper-icon-button>
                        </div>
                        <jv-datepicker id="{{assignCtrl('datePicker')}}" class="top10" date={{date}} modal></jv-datepicker>
                    </paper-card>
                </paper-dialog>
            </div>
            <div class="dateTimes">
                <paper-dialog class="timePicker z1000" id="{{assignCtrl('endDialog')}}" modal role="alertdialog">
                    <h2>End</h2>
                    <paper-card class="center">
                        <div class="topCorner">
                            <paper-icon-button suffix class="closeDialog" icon="clear" on-tap="closeEnd" class="topCorner"></paper-icon-button>
                        </div>
                        <jv-datepicker id="{{assignCtrl('endPicker')}}" class="top10" date={{end}} modal></jv-datepicker>
                    </paper-card>
                </paper-dialog>
            </div>
            <div class="dateTimes">
                <paper-dialog class="timePicker z1000" id="{{assignCtrl('startTimeDialog')}}" modal role="alertdialog">
                    <h2>Start</h2>
                    <paper-card class="center">
                        <div class="topCorner">
                            <paper-icon-button suffix class="closeDialog" icon="clear" on-tap="closeStartTime" class="topCorner"></paper-icon-button>
                        </div>
                        <paper-time-picker id="{{assignCtrl('startTimePicker')}}"></paper-time-picker>
                    </paper-card>
                </paper-dialog>
            </div>
            <div class="dateTimes">
                <paper-dialog class="timePicker z1000" id="{{assignCtrl('endTimeDialog')}}" modal role="alertdialog">
                    <h2>End</h2>
                    <paper-card class="center">
                        <div class="topCorner">
                            <paper-icon-button suffix class="closeDialog" icon="clear" on-tap="closeEndTime" class="topCorner"></paper-icon-button>
                        </div>
                        <paper-time-picker id="{{assignCtrl('endTimePicker')}}" class="editor"></paper-time-picker>
                    </paper-card>
                </paper-dialog>
            </div> 
            <google-map-search map="{{map}}" query="{{query}}" results="{{mapResult}}">
    </template>
</dom-module>
<script>
// I pass the button handler property from the base element, defined as the input
// The call back is made via document.querySelector on the input element name.

Polymer({
    is: "geoji-editor",
    properties: {
        title: {
            type: String,
            value: "",
            observer: "_setTitle",
            notify: true
        },
        private: {
            type: Boolean,
            value: false,
            observer: "_setPrivate",
            notify: true
        },
        encrypted: {
            type: Boolean,
            value: false,
            observer: "_setEncrypted",
            notify: true
        },
        anonymous: {
            type: Boolean,
            value: false,
            observer: "_setAnonymous",
            notify: false
        },
        invalid: {
            type: Boolean,
            value: true
        },
        cardImg: {
            type: String,
            value: ""
        },
        heading: {
            type: String,
            value: "GEOJI"
        },
        detail: {
            type: String,
            value: ""
        },
        date: {
            type: String,
            value: "",
            observer: "_validateDateTime",
            notify: true
        },
        end: {
            type: String,
            value: "",
            observer: "_validateDateTime",
            notify: true
        },
        startTime: {
            type: String,
            value: "",
            observer: "_validateDateTime",
            notify: true
        },
        endTime: {
            type: String,
            value: "",
            observer: "_validateDateTime",
            notify: true
        },
        dateTime: {
            type: Boolean,
            value: false
        },
        coverSet: {
            type: String,
            observer: "_setCoverImg",
            notify: true
        },
        coverImg: {
            type: String
        },
        description: {
            type: String,
            value: ""
        },
        currentLongitude: {
            type: String
        },
        currentLatitude: {
            type: String
        },
        markerArray: {
            type: Array,
            value: []
        },
        publicData: {
            type: Array,
            value: []
        },
        geoji: {
            type: Object,
            value: {}
        },
        geojiEncrypted: {
            type: Object,
            value: {}
        },
        vidTitle: {
            type: String,
            value: "new video",
            observer: "_setVidTitle",
            notify: true
        },
        vidPrivate: {
            type: Boolean,
            value: false,
            observer: "_setVidPrivate",
            notify: true
        },
        vidPrivacyStatus: {
            type: String,
            value: "public"
        },
        vidId: {
            type: String,
            value: "new video",
            observer: "_setVidId",
            notify: true
        },
        vidUrl: {
            type: String,
            value: null,
            observer: "_setVidUrl",
            notify: true
        },
        emailValue: {
            type: String,
            value: "",
            observer: "_storeEmails",
            notify: true
        },
        emailList: {
            type: Array,
            value: []
        },
        emailString: {
            type: String,
            value: ""
        },
        selectedMarker: {
            type: String
        },
        cipherKey: {
            type: String,
            value: null,
            observer: "_validateCipher",
            notify: true
        },
        firebaseKey: {
            type: String,
            value: null
        },
        uid: {
            type: String
        },
        query: {
            type: String
        },
        mapResult: {
            type: Array,
            value: [],
            observer: "_mapSearch",
            notify: true
        },
        employer: {
            type: String,
            value: ""
        },
        jobTitle: {
            type: String,
            value: ""
        },

    },
    observers: [
      '_checkValid(title.*)', '_checkValid(anonymous.*)', '_checkValid(date.*)', '_checkValid(end.*)', '_checkValid(startTime.*)', '_checkValid(endTime.*)',
      '_checkValid(encrypted.*)', '_checkValid(cipherKey.*)'
    ],

    behaviors: [StyleBehaviors.JStyles, InteractionBehaviors.JHandler, InteractionBehaviors.JEvents, SelectionBehaviors.AutoId,
        UtilityBehaviors.JUtil, CryptoBehaviors.JEncrypt, CryptoBehaviors.JDecrypt
    ],

    ready: function() {


    },
    attached: function() {
        var self = this;
        var map = this.getElem(this.ctrls.map);
        var location = this.getElem("geoLocation");
        var target = this.getElem(this.ctrls.targetMarker);
        var targetObj = {};
        var title = this.getElem(this.ctrls.title);
        var email = this.getElem(this.ctrls.email);
        var publicTgl = this.getElem(this.ctrls.public);
        var email = this.getElem(this.ctrls.email);
        var emailInput = this.getElem(this.ctrls.emailInput);
        var encrypt = this.getElem(this.ctrls.encrypt);
        var cipher = this.getElem(this.ctrls.cipher);
        var cipherInput = this.getElem(this.ctrls.cipherInput);
        var cipherCopy = this.getElem(this.ctrls.cipherCopy);
        var imgDialog = this.getElem(this.ctrls.imgDialog);
        var imgProcess = this.getElem(this.ctrls.imgProcess);
        var imgIcon = this.getElem(this.ctrls.imgIcon);
        var imgSpinner = this.getElem(this.ctrls.imgSpinner);
        var vidTitle = this.getElem(this.ctrls.vidTitleInput);
        var vidIcon = this.getElem(this.ctrls.vidIcon);
        var vidSpinner = this.getElem(this.ctrls.vidSpinner);
        var vidProgress = this.getElem(this.ctrls.vidProgress);
        var vidUrlInput = this.getElem(this.ctrls.vidUrlInput);
        var vidDialog = this.getElem(this.ctrls.vidDialog);
        var vidProcess = this.getElem(this.ctrls.vidProcess);
        var player = self.getElem(self.ctrls.youtubePlayer);
        var containerPrivate = this.getElem(this.ctrls.containerPrivate);
        var containerEncrypt = this.getElem(this.ctrls.containerEncrypt);
        var add = this.getElem(this.ctrls.add);
        var save = this.getElem(this.ctrls.save);
        var date = this.getElem(this.ctrls.datePicker);
        var end = this.getElem(this.ctrls.endPicker);

        var publicDB = this.getElem(this.ctrls.geojiPublic);
        var publicAuth = this.getElem(this.ctrls.publicAuth);
        var publicRef = publicAuth.ref;
        var privateDB = this.getElem(this.ctrls.geojiPrivate);
        var privateAuth = this.getElem(this.ctrls.privateAuth);
        var privateRef = privateAuth.ref;
        var mine = this.getElem(this.ctrls.geojiMine);
        var mineAuth = this.getElem(this.ctrls.mineAuth);

        var sysDate = new Date();
        var hours = sysDate.getHours();
        var minutes = sysDate.getMinutes();
        var timeOfDay = " AM";

        if (hours > 12) {
            hours = hours - 12;
            timeOfDay = " PM";
        }

        this.startTime = hours + ":" + minutes + timeOfDay;
        this.endTime = hours + ":" + minutes + timeOfDay;

        this.uid = app.data.uid;

        add.hidden = false;
        save.hidden = true;


        title.focus();
        title.value = " ";
        title.blur();

        imgProcess.handleDialog = imgDialog.id;
        imgProcess.handleElement = imgIcon.id;
        imgProcess.progressSpinner = imgSpinner.id;
        vidProcess.progressSpinner = vidSpinner.id;
        vidProcess.progressBar = vidProgress.id;
        vidProcess.videoIdInput = vidUrlInput.id;
        vidProcess.handleDialog = vidDialog.id;

        imgProcess.successCallback = function(e) {

            if (self.openEvents['imgur-upload-success']) {
                if (imgDialog.id === imgProcess.parentElement.id && !imgDialog.hidden && self.geoji[self.selectedMarker] !== undefined) {

                    self.geoji[self.selectedMarker].img = e.detail.link;
                    self.removeOpenEvent('imgur-upload-success');
                    imgDialog.toggle();
                }
            }
        }

        vidUrlInput.onchange = function(e) {

            var selected = self.geoji[self.selectedMarker];

            if (selected !== null && selected !== undefined) {
                if (selected.type === "vid") {
                    selected.link = vidUrlInput.value;
                }
            }

        };

        this.clipboard = new Clipboard(cipherCopy);

        var inlines = [containerPrivate, containerEncrypt];
        var containers = [containerPrivate, containerEncrypt];

        var topStyle = {
            "vertical-align": "top"
        }
        var halfStyle = {
            "width": "2vw"
        }
        var containerStyle = {
            "top": "1vh",
            "bottom": "1vh",
            "height": "11vh",
            "vertical-align": "top"
        }

        for (i in inlines) {
            this.assignClass(inlines[i], "inlineHalf");
        }

        for (i in containers) {
            this.assignStyles(containers[i], containerStyle);
        }


        this.geoji = {};

        map.mapType = "satellite";

        targetObj.longitude = this.currentLongitude;
        targetObj.latitude = this.currentLatitude;
        this.geoji.target = targetObj;


        this.geoji.private = publicTgl.checked;

        setTimeout(function() {

            var map = self.getElem(self.ctrls.map);
            var location = self.getElem("geoLocation");
            var pos;

            if (location.latitude === null || location.latitude === undefined) {
                if (navigator.geolocation) {
                    pos = navigator.geolocation.getCurrentPosition(showPosition);
                } else {
                    x.innerHTML = "Geolocation is not supported by this browser.";
                }

                function showPosition(position) {

                    self.currentLongitude = position.coords.longitude;
                    self.currentLatitude = position.coords.latitude;

                }
            }

            self.geoji.target.longitude = self.currentLongitude;
            self.geoji.target.latitude = self.currentLatitude;
            targetObj.longitude = self.currentLongitude;
            targetObj.latitude = self.currentLatitude;
            self.geoji.id = self.generateUid("_");
            self.geoji.date = self.date;
            date.minDate = self.date;
            self.geoji.end = self.end;
            end.minDate = self.end;
            self.geoji.startTime = hours + ":" + minutes + timeOfDay;
            self.geoji.endTime = hours + ":" + minutes + timeOfDay;

            self.currentLongitude = location.longitude;
            self.currentLatitude = location.latitude;

            target.longitude = location.longitude;
            target.latitude = location.latitude;

            mine.location = "https://geoji.firebaseio.com/mine/" + app.data.uid;
            mineAuth.location = "https://geoji.firebaseio.com/mine/" + app.data.uid;
            map["api-key"] = "AIzaSyCgmlzQ8iH-U2KDt2mhXJbZvQm-KB5dWSo";
            map.resize();

        }, 1000);

        setTimeout(function() {
            var profile = {};
            if (app.data.userName !== undefined && app.data.profileImg !== undefined) {
                profile.name = app.data.userName;
                profile.profileImg = app.data.profileImg;
            } else {
                profile.name = "unknown";
                profile.profileImg = "/images/mascot-unknown.png";
            }
            self.geoji.profile = profile;

        }, 2000);

        this.clipboard.on('success', function(e) {
            document.execCommand("copy", true, e.text);
        });
        this.clipboard.on('error', function(e) {
            console.log("ERROR!");
            console.log(e);
        });

        var onClick = function(e) {
            //console.log(e);
        };
        var mapDragEnd = function(e) {

            var target = self.getElem(self.ctrls.targetMarker);

            setTimeout(function() {
                if (data !== undefined || data !== null) {
                    self.geoji.target.longitude = e.target.longitude;
                    self.geoji.target.latitude = e.target.latitude;
                }
            }, 50);

            //console.log(self.geoji);
        };
        var targetDragEnd = function(e) {

            setTimeout(function() {
                if (data !== undefined || data !== null) {
                    self.geoji.target.longitude = e.target.longitude;
                    self.geoji.target.latitude = e.target.latitude;
                }
            }, 50);

        };

        // document.addEventListener('imgur-upload-success', function(e) {



        //   if(imgDialog.id === imgProcess.parentElement.id && !imgDialog.hidden && self.geoji[self.selectedMarker] !== undefined){

        //      self.geoji[self.selectedMarker].img = e.detail.link;

        //      imgDialog.toggle();
        //   }

        //       });
        document.addEventListener('imgur-upload-failure', function(e) {
            alert(e.detail.data.error);
        });

        map.resize();

        target.addEventListener('google-map-marker-dragend', targetDragEnd);
        map.addEventListener('google-map-dragend', mapDragEnd);

    },
    addGeoji: function() {
        var add = this.getElem(this.ctrls.add);
        var save = this.getElem(this.ctrls.save);
        var geoji = this.geoji;
        var cipher = this.getElem(this.ctrls.cipherInput).value;
        var saveDialog = this.getElem(this.ctrls.saveDialog);
        var saveSpinner = this.getElem(this.ctrls.saveSpinner);
        var mineFeed = this.getElem("mineFeed");
        var publicDB = this.getElem(this.ctrls.geojiPublic);
        publicDB.location = "https://geoji.firebaseio.com/public/";
        var privateDB = this.getElem(this.ctrls.geojiPrivate);
        privateDB.location = "https://geoji.firebaseio.com/private/";
        var mineDB = this.getElem(this.ctrls.geojiMine);
        mineDB.location = "https://geoji.firebaseio.com/mine/" + app.data.uid;
        var saveGeoji = {};

        if (this.geoji !== null && this.geoji !== undefined) {

            saveDialog.open();
            saveSpinner.active = true;

            if ((this.geoji.encrypted) && (cipher !== null || cipher !== undefined || cipher !== "")) {
                this._encryptGeoji();
            } else {
                if (!this.geoji.private) {
                    if (publicDB !== null && publicDB !== undefined) {
                        var obj = {};
                        obj.id = this.geoji.id;
                        obj.uid = app.data.uid;
                        publicDB.add(this.geoji);
                        mineDB.add(obj);
                        add.hidden = true;
                        save.hidden = false;
                        saveDialog.close();
                        saveSpinner.active = false;
                        mineFeed.render();
                    }
                } else {
                    if (privateDB !== null && privateDB !== undefined) {
                        var obj = {};
                        obj.id = this.geoji.id;
                        obj.uid = app.data.uid;
                        privateDB.add(this.geoji);
                        mineDB.add(obj);
                        add.hidden = true;
                        save.hidden = false;
                        saveDialog.close();
                        saveSpinner.active = false;
                        mineFeed.render();
                    }
                }
            }
        }


    },
    refreshMap: function() {
        var map = this.getElem(this.ctrls.map);
        map.resize();
    },
    refreshMine: function() {
        var mineFeed = this.getElem("geoMine");
        mineFeed.render();
    },
    setDate: function() {
        var dialog = this.getElem(this.ctrls.dateDialog);

        dialog.open();

    },
    closeDate: function() {
        var dialog = this.getElem(this.ctrls.dateDialog);
        var date = this.getElem(this.ctrls.datePicker);

        dialog.close();
        date.enforceDateChange();
        this.geoji.date = this.date;

    },
    setEnd: function() {
        var dialog = this.getElem(this.ctrls.endDialog);

        dialog.open();

    },
    closeEnd: function() {
        var dialog = this.getElem(this.ctrls.endDialog);
        var end = this.getElem(this.ctrls.endPicker);

        dialog.close();
        end.enforceDateChange();
        this.geoji.end = this.end;

    },
    setStartTime: function() {
        var dialog = this.getElem(this.ctrls.startTimeDialog);

        dialog.open();

    },
    closeStartTime: function() {
        var dialog = this.getElem(this.ctrls.startTimeDialog);
        var start = this.getElem(this.ctrls.startTimePicker);

        this.startTime = start.time;
        this.geoji.startTime = start.time;

        dialog.close();

    },
    setEndTime: function() {
        var dialog = this.getElem(this.ctrls.endTimeDialog);

        dialog.open();

    },
    closeEndTime: function() {
        var dialog = this.getElem(this.ctrls.endTimeDialog);
        var end = this.getElem(this.ctrls.endTimePicker);

        this.endTime = end.time;
        this.geoji.endTime = end.time;

        dialog.close();

    },
    saveGeoji: function() {
        var geoji = this.geoji;
        var cipher = this.getElem(this.ctrls.cipherInput).value;
        var saveDialog = this.getElem(this.ctrls.saveDialog);
        var saveSpinner = this.getElem(this.ctrls.saveSpinner);


        if (this.geoji !== null && this.geoji !== undefined) {

            if ((geoji.encrypted) && (cipher !== null || cipher !== undefined || cipher !== "")) {
                saveDialog.open();
                saveSpinner.active = true;
                this._encryptGeoji();
            } else {
                this.doSave();
            }
        }

    },
    buildGeoji: function(obj) {
        if (obj !== null) {
            var self = this;
            var map = this.getElem(this.ctrls.map);
            var target = this.getElem(this.ctrls.targetMarker);
            var title = self.getElem(self.ctrls.title);
            var email = self.getElem(self.ctrls.email);
            var email = self.getElem(self.ctrls.email);
            var emailInput = self.getElem(self.ctrls.emailInput);
            var add = self.getElem(self.ctrls.add);
            var save = self.getElem(self.ctrls.save);
            var encrypt = self.getElem(self.ctrls.encrypt);

            add.hidden = true;
            save.hidden = false;
            self.private = obj.private;
            map.clear();
            target = self.targetMarker(obj.target.longitude, obj.target.latitude, target.id);

            if (obj.title !== null && obj.title !== undefined) {
                title.value = obj.title;
            }

            if (obj.emailList !== null && obj.emailList !== undefined) {
                self.populateEmails(obj.emailList);
            }

            if (obj.encrypted) {
                encrypt.checked = true;
            }


            var markers = [];

            self.currentLatitude = obj.target.latitude;
            self.currentLongitude = obj.target.longitude;

            self.geoji = obj;

            for (k in obj) {
                if (obj[k].type !== null && obj[k].type !== undefined && k !== "target") {

                    switch (obj[k].type) {
                        case "txt":
                            marker = self.txtMarker(obj[k].longitude, obj[k].latitude, k);
                            break;
                        case "img":
                            marker = self.imgMarker(obj[k].longitude, obj[k].latitude, k);
                            break;
                        case "vid":
                            marker = self.vidMarker(obj[k].longitude, obj[k].latitude, k);
                            break;
                        default:

                    }
                }
            }

        } else {
            console.log("cannot load geoji with id: " + obj.id);
        }
    },
    loadGeoji: function(id) {
        var self = this;
        var map = this.getElem(this.ctrls.map);
        var target = this.getElem(this.ctrls.targetMarker);
        var publicDB = this.getElem(this.ctrls.geojiPublic);
        var publicAuth = this.getElem(this.ctrls.publicAuth);
        var publicRef = publicAuth.ref;
        var privateDB = this.getElem(this.ctrls.geojiPrivate);
        var privateAuth = this.getElem(this.ctrls.privateAuth);
        var privateRef = privateAuth.ref;
        var marker;

        var copy = target.cloneNode(true);

        if (this.geoji === null && this.geoji === undefined) {
            this.geoji = {};
        }

        this.geoji.id = id;

        var doLoad = function(obj) {
            if (obj !== null) {
                var title = self.getElem(self.ctrls.title);
                var email = self.getElem(self.ctrls.email);
                var email = self.getElem(self.ctrls.email);
                var emailInput = self.getElem(self.ctrls.emailInput);
                var add = self.getElem(self.ctrls.add);
                var save = self.getElem(self.ctrls.save);

                add.hidden = true;
                save.hidden = false;
                self.private = obj.private;
                self.date = obj.date;
                map.clear();
                target = self.targetMarker(obj.target.longitude, obj.target.latitude, target.id);

                if (obj.title !== null && obj.title !== undefined) {
                    title.value = obj.title;
                }

                if (obj.emailList !== null && obj.emailList !== undefined) {
                    self.populateEmails(obj.emailList);
                }


                if (obj.encrypted) {
                    var cipher = this.getElem(this.ctrls.cipherInput).value;
                    this.ecryptedObj = obj;
                    this.decryptedObj = obj;
                    decrypt_MainObj(0, cipher);
                } else {
                    var markers = [];

                    self.currentLatitude = obj.target.latitude;
                    self.currentLongitude = obj.target.longitude;

                    self.geoji = obj;

                    for (k in obj) {
                        if (obj[k].type !== null && obj[k].type !== undefined && k !== "target") {

                            switch (obj[k].type) {
                                case "txt":
                                    marker = self.txtMarker(obj[k].longitude, obj[k].latitude, k);
                                    break;
                                case "img":
                                    marker = self.imgMarker(obj[k].longitude, obj[k].latitude, k);
                                    break;
                                case "vid":
                                    marker = self.vidMarker(obj[k].longitude, obj[k].latitude, k);
                                    break;
                                default:

                            }
                        }
                    }
                }

            } else {
                console.log("cannot load geoji with id: " + id);
            }
        }

        publicRef.orderByChild("id").equalTo(id).on("child_added", function(snapshot) {
            var obj = snapshot.val()
            doLoad(obj);
        });

        privateRef.orderByChild("id").equalTo(id).on("child_added", function(snapshot) {
            var obj = snapshot.val()
            doLoad(obj);
        });

    },
    loadEncrypted: function(id) {
        var self = this;
        var map = this.getElem(this.ctrls.map);
        var cipherDialog = this.getElem(this.ctrls.cipherDialog);
        var decryptSpinner = this.getElem(this.ctrls.decryptSpinner);
        var target = this.getElem(this.ctrls.targetMarker);
        var publicDB = this.getElem(this.ctrls.geojiPublic);
        var publicAuth = this.getElem(this.ctrls.publicAuth);
        var publicRef = publicAuth.ref;
        var privateDB = this.getElem(this.ctrls.geojiPrivate);
        var privateAuth = this.getElem(this.ctrls.privateAuth);
        var privateRef = privateAuth.ref;
        var title = self.getElem(self.ctrls.title);
        var email = self.getElem(self.ctrls.email);
        var email = self.getElem(self.ctrls.email);
        var emailInput = self.getElem(self.ctrls.emailInput);
        var add = self.getElem(self.ctrls.add);
        var save = self.getElem(self.ctrls.save);

        publicRef.orderByChild("id").equalTo(id).on("child_added", function(snapshot) {
            var obj = snapshot.val()
            self.decryptedObj = {};
            self.encryptedObj = obj;
            cipherDialog.open();
            //doLoad(obj);
        });

        privateRef.orderByChild("id").equalTo(id).on("child_added", function(snapshot) {
            var obj = snapshot.val();
            self.decryptedObj = {};
            self.encryptedObj = obj;
            cipherDialog.open();
            //doLoad(obj);
        });


    },
    doSave: function() {
        var self = this;
        var publicDB = this.getElem(this.ctrls.geojiPublic);
        var publicAuth = this.getElem(this.ctrls.publicAuth);
        var publicRef = publicAuth.ref;
        var privateDB = this.getElem(this.ctrls.geojiPrivate);
        var privateAuth = this.getElem(this.ctrls.privateAuth);
        var privateRef = privateAuth.ref;
        var add = this.getElem(this.ctrls.add);
        var save = this.getElem(this.ctrls.save);
        var saveDialog = this.getElem(this.ctrls.saveDialog);
        var saveSpinner = this.getElem(this.ctrls.saveSpinner);
        var geoMine = this.getElem("geoMine");

        var complete = function() {
            if (add !== undefined && add !== null) {
                if (!add.hidden) {
                    add.hidden = true;
                    save.hidden = false;
                    saveSpinner.active = false;
                    saveDialog.close();
                    geoMine.refresh();
                } else if (add.hidden) {
                    saveSpinner.active = false;
                    saveDialog.close();
                    geoMine.refresh();
                }
            }
        }

        publicRef.orderByChild("id").equalTo(this.geoji.id).on("child_added", function(snapshot) {
            self.firebaseKey = snapshot.key();
            var obj = publicRef.child(snapshot.key());

            if (self.geoji.encrypted) {
                obj.set(self.geojiEncrypted);
                complete();
            } else {
                obj.set(self.geoji);
                complete();
            }

        });

        privateRef.orderByChild("id").equalTo(this.geoji.id).on("child_added", function(snapshot) {
            self.firebaseKey = snapshot.key();
            var obj = privateRef.child(snapshot.key());

            if (self.geoji.encrypted) {
                obj.set(self.geojiEncrypted);
                complete();
            } else {
                obj.set(self.geoji);
                complete();
            }

        });

    },
    loadMarker: function(long, lat, id) {

        var map = this.getElem(this.ctrls.map);
        var marker = document.createElement('google-map-marker');
        marker.setAttribute('latitude', lat);
        marker.setAttribute('longitude', long);
        marker.setAttribute('drag-events', true);
        marker.setAttribute('click-events', true);
        marker.draggable = true;
        marker.animation = "DROP";
        marker.id = this.addCtrl(id);

        return marker;
    },
    createMarker: function() {
        var map = this.getElem(this.ctrls.map);
        var id = this.makeId();
        var marker = document.createElement('google-map-marker');
        marker.setAttribute('latitude', this.currentLatitude);
        marker.setAttribute('longitude', this.currentLongitude);
        marker.setAttribute('drag-events', true);
        marker.setAttribute('click-events', true);
        marker.draggable = true;
        marker.animation = "DROP";
        marker.id = this.assignCtrl(id);
        // map.resize();

        return marker;
    },
    setMarkerListeners: function(id, click, dblclick, dragend) {

        var self = this;

        setTimeout(function() {
            var elem = self.getElem(id);
            self.markerArray.push(id);
            elem.addEventListener('google-map-marker-click', click);
            elem.addEventListener('google-map-marker-click', dblclick);
            elem.addEventListener('google-map-marker-dragend', dragend);
        }, 50);
    },
    storeMarker: function(id, obj) {
        this.geoji[id] = obj;
    },
    toggleDialog: function(event) {
        var id = event.target.id;
        var type = this.geoji[id].type;
        var message = this.geoji[id].message;
        var marker = document.querySelector("#" + id);

        if (type !== undefined && type !== null) {

            if (type === "img") {
                var coverImg = this.coverImg;
                var coverSet = this.coverSet;
                var coverToggle = this.getElem(this.ctrls.coverImg);
                var imgUrl = this.geoji[id].img;
                var imgProcess = this.getElem(this.ctrls.imgProcess);
                var imgIcon = this.getElem(this.ctrls.imgIcon);


                this.getElem(this.ctrls.imgProcess).hideButtons = false;


            }

            var e = this.getElem(this.ctrls[type + "Dialog"]);
            e.toggle();

        }

    },
    toggleTxtDialog: function() {

        var e = this.getElem(this.ctrls.txtDialog);
        e.toggle();
    },
    toggleDecryptDialog: function() {

        var e = this.getElem(this.ctrls.cipherDialog);
        e.toggle();
    },
    targetMarker: function(long, lat, id) {

        var self = this;
        var map = this.getElem(this.ctrls.map);
        var geoji = this.geoji;
        var target = document.createElement('google-map-marker');

        target.setAttribute('name', "targetMarker");
        target.setAttribute('latitude', lat);
        target.setAttribute('longitude', long);
        target.setAttribute('drag-events', true);
        target.setAttribute('click-events', true);
        target.draggable = true;
        target.animation = "DROP";

        target.icon = "/images/marker-target.png";

        var onClick = function(e) {
            //console.log(e);
        };

        var targetDragEnd = function(e) {

            setTimeout(function() {
                if (data !== undefined || data !== null) {
                    self.geoji.target.longitude = e.target.longitude;
                    self.geoji.target.latitude = e.target.latitude;
                }
            }, 50);

        };

        target.addEventListener('google-map-marker-dragend', targetDragEnd);

        Polymer.dom(map).appendChild(target);

        return target;

    },
    txtMarker: function(long, lat, id) {
        var self = this;
        var map = this.getElem(this.ctrls.map);
        var txt = this.getElem(this.ctrls.txtInput);
        var geoji = this.geoji;
        var doUpdate = true;
        var marker;


        if (typeof long === "number") {
            marker = this.loadMarker(long, lat, id);
            marker.icon = "/images/mascot-txt.png";
            doUpdate = false;
        } else {
            marker = this.createMarker();
            marker.icon = "/images/mascot-txt.png";
        }

        var onClick = function(e) {

        };
        var dblClick = function(e) {
            var message = self.geoji[e.target.id].message;
            self.selectedMarker = e.target.id;

            if (message !== null && message !== undefined) {

                txt.value = message;
            } else if (message === null || message === undefined) {

                txt.value = "";
            }

            self.toggleDialog(e);

        };
        var onDragEnd = function(e) {
            var latLng = self.pixelOffsetToLatLng(e.detail.pixel.x, e.detail.pixel.y);
            var data = geoji[marker.id];
            var pos = this.position;

            setTimeout(function() {
                if (data !== undefined || data !== null) {
                    data.longitude = e.target.longitude;
                    data.latitude = e.target.latitude;
                }
            }, 50);
        };

        Polymer.dom(map).appendChild(marker);
        this.setMarkerListeners(marker.id, onClick, dblClick, onDragEnd);
        if (doUpdate) {
            self.updateMarker(marker);
        }

    },
    saveTxt: function() {
        var txt = this.getElem(this.ctrls.txtInput);
        var marker = this.getElem(this.selectedMarker);
        var type = this.geoji[marker.id].type;

        if (type == "txt") {
            this.geoji[marker.id].message = txt.value;
            this.toggleTxtDialog();
            txt.value = "";
        }

    },
    imgMarker: function(long, lat, id) {
        var self = this;
        var map = this.getElem(this.ctrls.map);
        var geoji = this.geoji;
        var doUpdate = true;
        var marker;

        if (typeof long === "number") {
            marker = this.loadMarker(long, lat, id);
            marker.icon = "/images/mascot-img.png";
            doUpdate = false;
        } else {
            marker = this.createMarker();
            marker.icon = "/images/mascot-img.png";
        }

        var onClick = function(e) {
            //console.log(e);
        };
        var dblClick = function(e) {
            var imgUrl = self.geoji[e.target.id].img;
            var imgProcess = self.getElem(self.ctrls.imgProcess);
            var imgIcon = self.getElem(self.ctrls.imgIcon);
            var coverToggle = self.getElem(self.ctrls.coverImg);
            var data = geoji[e.target.id];

            self.toggleDialog(e);
            self.selectedMarker = e.target.id;
            imgProcess.hideImgPreview();
            imgIcon.hidden = false;

            if (imgUrl !== null && imgUrl !== undefined) {
                imgIcon.hidden = true;
                coverToggle.hidden = false;
                imgProcess.hideCropper();
                imgProcess.showImgPreview(imgUrl);
                if (imgUrl == self.coverImg) {
                    coverToggle.checked = true;
                } else {
                    coverToggle.checked = false;
                }
            } else {
                self.addOpenEvent('imgur-upload-success', true);
                imgProcess.hideCropper();
                imgIcon.hidden = false;
                coverToggle.hidden = true;
            }
        };
        var onDragEnd = function(e) {
            var latLng = self.pixelOffsetToLatLng(e.detail.pixel.x, e.detail.pixel.y);
            var data = geoji[marker.id];

            setTimeout(function() {
                if (data !== undefined || data !== null) {
                    data.longitude = e.target.longitude;
                    data.latitude = e.target.latitude;
                }
            }, 50);
        };

        Polymer.dom(map).appendChild(marker);
        this.setMarkerListeners(marker.id, onClick, dblClick, onDragEnd);
        if (doUpdate) {
            this.updateMarker(marker);
        }

    },
    vidMarker: function(long, lat, id) {
        var self = this;
        var map = this.getElem(this.ctrls.map);
        var geoji = this.geoji;
        var doUpdate = true;
        var marker;

        if (typeof long === "number") {
            marker = this.loadMarker(long, lat, id);
            marker.icon = "/images/mascot-vid.png";
            doUpdate = false;
        } else {
            marker = this.createMarker();
            marker.icon = "/images/mascot-vid.png";
        }

        var onClick = function(e) {

        };
        var dblClick = function(e) {
            self.toggleDialog(e);
            self.selectedMarker = e.target.id;
            if (self.geoji[e.target.id] !== null && self.geoji[e.target.id] !== undefined) {

                var marker = self.geoji[e.target.id];
                var vidTitle = self.getElem(self.ctrls.vidTitle);
                var vidTitleInput = self.getElem(self.ctrls.vidTitleInput);
                var vidId = self.getElem(self.ctrls.vidUrlInput);
                var vidIcon = self.getElem(self.ctrls.vidIcon);
                var player = self.getElem(self.ctrls.youtubePlayer);


                if (marker.link !== null && marker.link !== undefined && marker.link !== "") {
                    console.log(marker.link);
                    vidTitle.hidden = true;

                    if (vidId !== null && vidId !== undefined) {
                        vidId.value = marker.link;
                        self.vidUrl = marker.link;
                        self.vidId = marker.link.replace("https://youtu.be/", "");
                    }

                    vidIcon.hidden = true;
                    player.hidden = false;
                } else {
                    vidTitle.hidden = false;
                    vidTitleInput.focus();
                    vidTitleInput.value = "new video";
                    vidTitleInput.blur();

                    if (vidId !== null && vidId !== undefined) {
                        vidId.value = "";
                        self.vidUrl = "";
                    }

                    vidIcon.hidden = false;
                    player.hidden = true;
                }

            }
        };
        var onDragEnd = function(e) {
            var latLng = self.pixelOffsetToLatLng(e.detail.pixel.x, e.detail.pixel.y);
            var data = geoji[marker.id];

            setTimeout(function() {
                if (data !== undefined || data !== null) {
                    data.longitude = e.target.longitude;
                    data.latitude = e.target.latitude;
                }
            }, 50);
        };

        Polymer.dom(map).appendChild(marker);
        this.setMarkerListeners(marker.id, onClick, dblClick, onDragEnd);

        if (doUpdate) {
            this.updateMarker(marker);
        }

    },
    updateMarker: function(marker) {

        var target = this.getElem(this.ctrls.targetMarker);
        var targetObj = {};
        var icon = marker.icon;
        var obj = {};


        if (icon !== null) {
            if (icon.includes("txt") > 0) {
                obj.type = "txt";
            } else if (icon.includes("img") > 0) {
                obj.type = "img";
            } else if (icon.includes("vid") > 0) {
                obj.type = "vid";
            }
        }
        targetObj.longitude = target.longitude;
        targetObj.latitude = target.latitude;
        this.geoji.target = targetObj;
        obj.latitude = marker.latitude;
        obj.longitude = marker.longitude;
        this.geoji[marker.id] = obj;
    },
    pixelOffsetToLatLng: function(offsetx, offsety) {
        var map = document.querySelector('google-map').map;
        var latlng = map.getCenter();
        var scale = Math.pow(2, map.getZoom());
        var nw = new google.maps.LatLng(
            map.getBounds().getNorthEast().lat(),
            map.getBounds().getSouthWest().lng()
        );

        var worldCoordinateCenter = map.getProjection().fromLatLngToPoint(latlng);
        var pixelOffset = new google.maps.Point((offsetx / scale) || 0, (offsety / scale) || 0);

        var worldCoordinateNewCenter = new google.maps.Point(
            worldCoordinateCenter.x - pixelOffset.x,
            worldCoordinateCenter.y + pixelOffset.y
        );

        var latLngPosition = map.getProjection().fromPointToLatLng(worldCoordinateNewCenter);

        return latLngPosition;
    },
    addEmail: function() {
        var input = this.getElem(this.ctrls.emailInput);
        var email = this.getElem(this.ctrls.email);

        if (this.emailValidate() && (!this.emailString.includes(this.emailValue))) {
            input.invalid = false;
            this.emailString += "  " + this.emailValue + ",";
            this.emailList.push(this.emailValue);
            this.geoji.emailList.push(this.emailValue);
            input.value = "";
        } else {
            email.invalid = true;
            input.value = "";
        }


    },
    populateEmails: function(list) {

        for (item in list) {

            if (!this.emailString.includes(list[item])) {
                this.emailString += "  " + list[item] + ",";
                this.emailList.push(list[item]);
            }
        }

    },
    createcipher: function() {
        var symbols = ["!", "@", "$", "%", "^", "&", "*", "_"];
        var caps = ["A", "B", "C", "D", "E", "F", "G", "H", "I",
            "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
            "U", "V", "W", "X", "Y", "Z"
        ];
        var sym1 = symbols[this.getRandomInt(0, symbols.length)];
        var sym2 = symbols[this.getRandomInt(0, symbols.length)];
        var cap1 = caps[this.getRandomInt(0, caps.length)];
        var cap2 = caps[this.getRandomInt(0, caps.length)];
        var randomString = Math.random().toString(36).slice(-8) + Math.random().toString(36).slice(-8) + sym1 + sym2 + cap1 + cap2;
        randomString = this.shuffleString(randomString);

        var cipherInput = this.getElem(this.ctrls.cipherInput);

        cipherInput.value = randomString;
        this.cipherKey = randomString;
    },
    copycipher: function() {
        var cipherInput = this.getElem(this.ctrls.cipherInput);
        var cipherCopy = this.getElem(this.ctrls.cipherCopy);
        var hidden = document.querySelector("#cipherHidden");
        var cipher = cipherInput.value;
        hidden.value = cipher;

        cipherCopy["data-clipboard-text"] = cipher;
        //console.log(this.clipboard);

        //window.prompt("Copy to clipboard: Ctrl+C, Enter", cipherInput.value);
    },
    encrypt_MainKey: function(key, data, cipher, i) {
        var self = this;

        if (data.toString() === "true" || data.toString() === "false") {
            data = data.toString();
        }

        triplesec.encrypt({

            data: new triplesec.Buffer(data.toString()),
            key: new triplesec.Buffer(self.cipherKey),
            progress_hook: function(obj) { /* ... */ }

        }, function(err, buff) {

            if (!err) {
                var ciphertext = buff.toString('hex');
                var keys = Object.keys(self.geoji);
                var eKeys = Object.keys(self.geojiEncrypted);

                self.geojiEncrypted[key] = ciphertext;

                if (keys.length === eKeys.length) {
                    console.log("OBJECT SHOULD BE ENCRYPTED");
                } else {
                    self.encrypt_MainObj(i + 1, cipher);
                }
            }

        });

    },
    encrypt_InnerData: function(key, obj, innerKey, data, cipher, i, j) {
        var keys = Object.keys(obj);
        var self = this;

        if (data.toString() === "true" || data.toString() === "false") {
            data = data.toString();
        }

        triplesec.encrypt({

            data: new triplesec.Buffer(data.toString()),
            key: new triplesec.Buffer(self.cipherKey),
            progress_hook: function(obj) { /* ... */ }

        }, function(err, buff) {

            if (!err) {
                var ciphertext = buff.toString('hex');
                var keys = Object.keys(obj);
                var eKeys = Object.keys(self.geojiEncrypted);
                var gKeys = Object.keys(self.geoji);

                if (self.geojiEncrypted[key] === null || self.geojiEncrypted[key] === undefined) {
                    self.geojiEncrypted[key] = {};
                }

                if (innerKey.toString() !== "type" && innerKey.toString() !== "private") {

                    self.geojiEncrypted[key][innerKey] = ciphertext;
                } else if (innerKey.toString() === "type") {

                    self.geojiEncrypted[key].type = self.geoji[key].type;
                } else if (innerKey.toString() === "private") {
                    self.geojiEncrypted[key].private = self.geoji[key].private;
                }

                if (keys.length === j + 1) {

                    self.encrypt_MainObj(i + 1, cipher);

                } else if (keys.length > j + 1) {

                    self.encrypt_InnerObj(key, obj, cipher, i, j + 1);
                }

            }

        });

    },
    encrypt_InnerObj: function(key, obj, cipher, i, j) {
        var keys = Object.keys(obj);

        this.encrypt_InnerData(key, obj, keys[j], obj[keys[j]], cipher, i, j);

    },
    encrypt_ArrayElem: function(key, array, cipher, i, j) {
        self = this;
        triplesec.encrypt({

            data: new triplesec.Buffer(array[j].toString()),
            key: new triplesec.Buffer(self.cipherKey),
            progress_hook: function(obj) { /* ... */ }

        }, function(err, buff) {

            if (!err) {
                var ciphertext = buff.toString('hex');
                var eKeys = Object.keys(self.geojiEncrypted);
                var gKeys = Object.keys(self.geoji);

                if (self.geojiEncrypted[key] === null || self.geojiEncrypted[key] === undefined) {
                    self.geojiEncrypted[key] = [];
                }

                self.geojiEncrypted[key][j] = ciphertext;

                if (j + 1 === array.length) {

                    self.encrypt_MainObj(i + 1, cipher);

                } else if (array.length > j + 1) {
                    self.encrypt_Array(key, array, cipher, i, j + 1);
                }

            }

        });
    },
    encrypt_Array: function(key, array, cipher, i, j) {
        var self = this;

        if (array.constructor === Array) {
            self.encrypt_ArrayElem(key, array, cipher, i, j);
        } else {
            console.log("Must be type of array to encrypt.")
        }

    },
    encrypt_MainObj: function(i, cipher) {
        console.log("do encrypt");
        var self = this;
        var keys = Object.keys(self.geoji);
        var eKeys = Object.keys(self.geojiEncrypted);
        var gKeys = Object.keys(self.geoji);
        var add = this.getElem(this.ctrls.add);
        var save = this.getElem(this.ctrls.save);
        var saveDialog = this.getElem(this.ctrls.saveDialog);
        var saveSpinner = this.getElem(this.ctrls.saveSpinner);
        var encryptProgress = this.getElem(this.ctrls.encryptProgress);
        var mineFeed = this.getElem("mineFeed");

        encryptProgress.value = eKeys.length * 10;

        var encryptComplete = function() {
            if (add !== undefined && add !== null) {
                if (!add.hidden) {
                    encryptProgress.value = 0;
                    add.hidden = true;
                    save.hidden = false;
                    saveSpinner.active = false;
                    saveDialog.close();
                    mineFeed.render();
                } else {

                }
            }
        }

        if (cipher !== null && cipher !== undefined && cipher !== "undefined" && cipher !== "") {
            if (gKeys.length === eKeys.length) {
                var publicDB = this.getElem(this.ctrls.geojiPublic);
                publicDB.location = "https://geoji.firebaseio.com/public/";
                var privateDB = this.getElem(this.ctrls.geojiPrivate);
                privateDB.location = "https://geoji.firebaseio.com/private/";
                var mineDB = this.getElem(this.ctrls.geojiMine);
                mineDB.location = "https://geoji.firebaseio.com/mine/" + app.data.uid;
                console.log("ALL DATA SHOULD BE ENCRYPTED.");

                if (this.geojiEncrypted.private && privateDB !== null && privateDB !== undefined) {
                    if (add !== undefined && add !== null && save !== undefined && save !== null) {
                        if (!add.hidden) {
                            var obj = {};
                            obj.id = this.geoji.id;
                            obj.uid = app.data.uid;
                            privateDB.add(self.geojiEncrypted);
                            mineDB.add(obj);
                            encryptComplete();
                        } else {
                            this.doSave();
                        }
                    }
                } else if (!this.geojiEncrypted.private && publicDB !== null && publicDB !== undefined) {
                    console.log("Should add to public db");
                    if (add !== undefined && add !== null && save !== undefined && save !== null) {
                        if (!add.hidden) {
                            console.log("ADD THE GEOJI");
                            var obj = {};
                            obj.id = this.geoji.id;
                            obj.uid = app.data.uid;
                            publicDB.add(self.geojiEncrypted);
                            mineDB.add(obj);
                            encryptComplete();

                        } else {
                            console.log("SAVE THE GEOJI");
                            this.doSave();
                        }
                    }
                }
            } else {
                switch (keys[i]) {
                    case "id":
                        if (self.geoji.id !== null && self.geoji.id !== undefined) {
                            self.geojiEncrypted.id = self.geoji.id;
                            self.encrypt_MainObj(i + 1, cipher);
                        } else {
                            console.log("id isnt defined.");
                        }
                        break;
                    case "profile":
                        if (self.geoji.profile !== null && self.geoji.profile !== undefined) {
                            self.geojiEncrypted.profile = self.geoji.profile;
                            self.encrypt_MainObj(i + 1, cipher);
                        } else {
                            console.log("id isnt defined.");
                        }
                        break;
                    case "title":
                        console.log("encrypt title");
                        self.encrypt_MainKey(keys[i], self.geoji.title, cipher, i);
                        break;
                    case "date":
                        if (self.geoji.date !== null && self.geoji.date !== undefined) {
                            self.geojiEncrypted.date = self.geoji.date;
                            self.encrypt_MainObj(i + 1, cipher);
                        } else {
                            console.log("date isnt defined.");
                        }
                        break;
                    case "end":
                        if (self.geoji.end !== null && self.geoji.end !== undefined) {
                            self.geojiEncrypted.end = self.geoji.end;
                            self.encrypt_MainObj(i + 1, cipher);
                        } else {
                            console.log("date isnt defined.");
                        }
                        break;
                    case "startTime":
                        if (self.geoji.startTime !== null && self.geoji.startTime !== undefined) {
                            self.geojiEncrypted.startTime = self.geoji.startTime;
                            self.encrypt_MainObj(i + 1, cipher);
                        } else {
                            console.log("startTime isnt defined.");
                        }
                        break;
                    case "endTime":
                        if (self.geoji.endTime !== null && self.geoji.endTime !== undefined) {
                            self.geojiEncrypted.endTime = self.geoji.endTime;
                            self.encrypt_MainObj(i + 1, cipher);
                        } else {
                            console.log("endTime isnt defined.");
                        }
                        break;
                    case "private":

                        if (self.geoji.private !== null && self.geoji.private !== undefined) {
                            self.geojiEncrypted.private = self.geoji.private;
                            self.encrypt_MainObj(i + 1, cipher);
                        } else {
                            console.log("date isnt defined.");
                        }
                        break;
                    case "encrypted":
                        console.log("encrypt encrypted");

                        if (self.geoji.encrypted !== null && self.geoji.encrypted !== undefined) {
                            self.geojiEncrypted.encrypted = true;
                            self.encrypt_MainObj(i + 1, cipher);
                        } else {
                            console.log("encrypted isnt defined.");
                        }
                        break;
                    case "emailList":
                        console.log("encrypt email list");

                        if (self.geoji.emailList !== null && self.geoji.emailList !== undefined && self.geoji.emailList.length > 0) {
                            self.geojiEncrypted.emailList = [];
                            self.encrypt_Array(keys[i], self.geoji.emailList, cipher, i, 0);
                        } else {
                            self.geojiEncrypted.emailList = [];
                            self.encrypt_MainObj(i + 1, cipher);
                        }

                        break;
                    case "target":

                        if (self.geoji.target !== null && self.geoji.target !== undefined) {

                            self.geojiEncrypted.target = self.geoji.target;
                            self.encrypt_MainObj(i + 1, cipher);
                        }
                        break;
                    default:
                        console.log("default");
                        console.log(keys[i]);

                        if (typeof self.geoji[keys[i]] === "object") {
                            console.log("encrypting innerObj");
                            self.encrypt_InnerObj(keys[i], self.geoji[keys[i]], cipher, i, 0);
                        }

                        break;
                }
            }
        } else {
            alert("a cipher needs to be defined!");
            saveSpinner.active = false;
            saveDialog.close();
        }

    },
    decrypt_MainObj: function(i, cipher) {
        var self = this;
        this.geoji = this.decryptedObj;
        var keys = Object.keys(self.encryptedObj);
        var dKeys = Object.keys(self.decryptedObj);
        var eKeys = Object.keys(self.encryptedObj);
        var add = this.getElem(this.ctrls.add);
        var save = this.getElem(this.ctrls.save);
        var saveDialog = this.getElem(this.ctrls.saveDialog);
        var decryptSpinner = this.getElem(this.ctrls.decryptSpinner);
        var decryptProgress = this.getElem(this.ctrls.decryptProgress);

        this.decryptCallback = this.decrypt_MainObj;
        decryptProgress.value = dKeys.length * 10;

        if (this.decryptedObj === null && this.decryptedObj === undefined) {
            this.decryptedObj = {};
        }

        var decryptComplete = function() {
            if (add !== undefined && add !== null) {
                if (!add.hidden) {
                    add.hidden = true;
                    save.hidden = false;
                    saveSpinner.active = false;
                    saveDialog.close();
                } else {

                }
            }
        }

        if (eKeys.length === dKeys.length) {
            var cipherDialog = this.getElem(this.ctrls.cipherDialog);

            cipherDialog.close();
            decryptProgress.value = 0;
            decryptSpinner.active = false;
            this.buildGeoji(this.decryptedObj);

            console.log("ALL DATA SHOULD BE DECRYPTED.");

        } else {
            switch (keys[i]) {
                case "id":
                    if (self.encryptedObj.id !== null && self.encryptedObj.id !== undefined) {
                        self.decryptedObj.id = self.encryptedObj.id;
                        self.decrypt_MainObj(i + 1, this.cipherKey);
                    }
                    break;
                case "profile":
                    if (self.encryptedObj.profile !== null && self.encryptedObj.profile !== undefined) {
                        self.decryptedObj.profile = self.encryptedObj.id;
                        self.decrypt_MainObj(i + 1, this.cipherKey);
                    }
                    break;
                case "title":
                    console.log("decrypt title");

                    self.decryptMainKey(keys[i], self.encryptedObj.title, this.cipherKey, i);
                    break;
                case "date":
                    if (self.encryptedObj.date !== null && self.encryptedObj.date !== undefined) {
                        self.decryptedObj.date = self.encryptedObj.date;
                        self.decrypt_MainObj(i + 1, this.cipherKey);
                    }
                    break;
                case "end":
                    if (self.encryptedObj.end !== null && self.encryptedObj.end !== undefined) {
                        self.decryptedObj.end = self.encryptedObj.end;
                        self.decrypt_MainObj(i + 1, this.cipherKey);
                    }
                    break;
                case "startTime":
                    if (self.encryptedObj.startTime !== null && self.encryptedObj.startTime !== undefined) {
                        self.decryptedObj.startTime = self.encryptedObj.startTime;
                        self.decrypt_MainObj(i + 1, this.cipherKey);
                    }
                    break;
                case "endTime":
                    if (self.encryptedObj.endTime !== null && self.encryptedObj.endTime !== undefined) {
                        self.decryptedObj.endTime = self.encryptedObj.endTime;
                        self.decrypt_MainObj(i + 1, this.cipherKey);
                    }
                    break;
                case "private":

                    if (self.encryptedObj.private !== null && self.encryptedObj.private !== undefined) {
                        self.decryptedObj.private = self.encryptedObj.private;
                        self.decrypt_MainObj(i + 1, this.cipherKey);
                    }
                    break;
                case "encrypted":
                    console.log("decrypt encrypted");

                    if (self.encryptedObj.encrypted !== null && self.encryptedObj.encrypted !== undefined) {
                        self.decryptedObj.encrypted = true;
                        self.decrypt_MainObj(i + 1, this.cipherKey);
                    }
                    break;
                case "emailList":
                    console.log("decrypt email list");

                    if (self.encryptedObj.emailList !== null && self.encryptedObj.emailList !== undefined) {
                        self.decryptedObj.emailList = [];
                        self.decryptArray(keys[i], self.encryptedObj.emailList, this.cipherKey, i, 0);
                    }

                    break;
                case "target":

                    if (self.encryptedObj.target !== null && self.encryptedObj.target !== undefined) {
                        self.decryptedObj.target = self.encryptedObj.target;
                        self.decrypt_MainObj(i + 1, this.cipherKey);
                    }
                    break;
                default:
                    console.log("decrypt default");

                    if (typeof self.encryptedObj[keys[i]] === "object") {
                        console.log("decrypting innerObj");
                        self.decryptedObj[keys[i]] = {};
                        self.decryptInnerObj(keys[i], self.encryptedObj[keys[i]], this.cipherKey, i, 0);
                    }

                    break;
            }
        }

    },
    _encryptGeoji: function() {
        var cipher = this.getElem(this.ctrls.cipherInput).value;

        this.geojiEncrypted = {};
        this.encrypt_MainObj(0, cipher);

    },
    _decryptGeoji: function() {
        var cipher = this.getElem(this.ctrls.decryptInput).value;
        var decryptSpinner = this.getElem(this.ctrls.decryptSpinner);

        decryptSpinner.active = true;

        this.skipKeys = ["id", "type", "date", "target"];

        this.decrypt_MainObj(0, this.cipherKey);
    },
    _getCurrentLocation: function() {
        console.log("getting current location.");
    },
    _setTitle: function() {
        var title = this.getElem(this.ctrls.title);

        if (title !== null) {
            this.geoji.title = title.value;
        }
    },
    _setPrivate: function() {
        var userEmail = app.data.email;
        var emailInput = this.getElem(this.ctrls.emailInput);
        var geojiEmails;
        var pToggle = this.getElem(this.ctrls.public);

        if ((this.geoji !== null && this.geoji !== undefined)) {
            var geojiEmails = this.geoji.emailList;
            if (geojiEmails === null || geojiEmails === undefined) {
                this.geoji.emailList = [];
            }
        }

        if (pToggle !== null) {
            this.geoji.private = pToggle.checked;
            this.getElem(this.ctrls.email).hidden = !pToggle.checked;

            if (this.getElem(this.ctrls.email).hidden === false) {
                emailInput.focus();
                emailInput.value = " ";
                emailInput.blur();
                if (!this.emailString.includes(userEmail)) {
                    this.emailString += "  " + userEmail + ",";
                    this.emailList.push(userEmail);
                    this.geoji.emailList.push(userEmail);
                }
            } else if (this.getElem(this.ctrls.email).hidden === true) {
                this.emailString = " ";
                this.emailList = [];
                this.geoji.emailList = [];
            }

        }
    },
    _setEncrypted: function() {
        var cipherInput = this.getElem(this.ctrls.cipherInput);
        var pToggle = this.getElem(this.ctrls.encrypt);

        if (pToggle !== null) {
            this.geoji.encrypted = pToggle.checked;
            this.getElem(this.ctrls.cipher).hidden = !pToggle.checked;
            if (this.getElem(this.ctrls.cipher).hidden === false) {
                cipherInput.focus();
                cipherInput.value = "undefined";
                cipherInput.blur();
            }
        }
    },
    _setAnonymous: function() {
        var profile = {};

        console.log(this.anonymous);

        if (this.geoji !== null && this.geoji !== undefined && this.anonymous !== null && this.anonymous !== undefined) {

            if (this.anonymous) {
                profile.name = "unknown";
                profile.profileImg = "/images/mascot-unknown.png";
                this.geoji.profile = profile;
            } else {
                profile.name = app.data.userName;
                profile.profileImg = app.data.profileImg;
                this.geoji.profile = profile;
            }

            console.log(app.data);
        }
    },
    _setCoverImg: function() {

        if (this.coverSet === true) {
            if (this.geoji !== null && this.geoji !== undefined) {
                if (this.selectedMarker !== null && this.selectedMarker !== undefined) {
                    var marker = this.getElem(this.selectedMarker);
                    var data = this.geoji[this.selectedMarker];
                    if (data.type === "img" && data.img !== null && data.img !== undefined) {
                        this.geoji.coverImg = data.img;
                        this.coverImg = data.img;
                    }
                }
            }
        } else {

        }


    },
    emailValidate: function() {
        var input = this.getElem(this.ctrls.emailInput);
        var email = this.getElem(this.ctrls.email);
        var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
        console.log(input.value);

        if (email !== null && input !== null && re.test(input.value)) {
            if (input.value.includes('@') && input.value.includes('.')) {
                email.invalid = false;
                return true;
            } else {
                return false;
            }
        }
    },
    _validateCipher: function() {
        var input = this.getElem(this.ctrls.cipherInput);
        var cipher = this.getElem(this.ctrls.cipher);
        var re = /^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[^\w\s]).{8,}$/;

        if (cipher !== null && cipher !== undefined && input !== null && input !== undefined && this.cipherKey !== null && this.cipherKey !== undefined) {
            cipher.invalid = !re.test(this.cipherKey);
        }

    },
    _validateDateTime: function(){
        var dateInput = this.getElem(this.ctrls.dateInput);
        var endInput = this.getElem(this.ctrls.endInput);
        var startTimeInput = this.getElem(this.ctrls.startTimeInput);
        var endTimeInput = this.getElem(this.ctrls.endTimeInput);
        var datesValid = false;
        var icon = this.getElem(this.ctrls.dateIcon);
        var self = this;


        if(this.date !== null && this.date !== undefined
            && this.startTime !== null && this.startTime !== undefined
            && this.endTime !== null && this.endTime !== undefined
            && this.date !== null && this.date !== undefined
            && this.end !== null && this.end !== undefined){

            var doValidate = function(dateArr, stTimeArr, endArr, enTimeArr){

                if(stTimeArr[1] !== undefined && enTimeArr[1] !== undefined)
                {

                    var stMinArr = stTimeArr[1].split(" ");
                    var stHours = parseFloat(stTimeArr[0]);
                    var stMinutes = parseFloat(stMinArr[0]);
                    var stTimeDay = stMinArr[1];
                    var date = [];
                    var enMinArr = enTimeArr[1].split(" ");
                    var enHours = parseFloat(enTimeArr[0]);
                    var enMinutes = parseFloat(enMinArr[0]);
                    var enTimeDay = enMinArr[1];
                    var end = [];
                    var errors = [];


                    for(i in dateArr)
                    {
                        date.push(parseFloat(dateArr[i]));
                    }

                    for(i in endArr)
                    {
                        end.push(parseFloat(endArr[i]));
                    }

                    var dateChecker = function(int){
                        //if on the same day
                            if(date[int]==end[int])
                            {//if on the same day
                                return 0;    
                            }
                            else if(date[int]<end[int])
                            {//if start day before end day
                                return 1; 
                            }
                            else if(date[int]>end[int])
                            {
                                return -1;
                            }
                    }

                    var year = function(){
                        //if on the same day
                        return dateChecker(0)
                    }

                    var month = function(){
                        //if on the same day
                        return dateChecker(1)
                    }

                    var day = function(){
                        //if on the same day
                        return dateChecker(2)
                    }

                    var hour = function(){
                        if(stHours === enHours)
                        {
                            return 0;
                        }
                        else if(stHours < enHours)
                        {

                            if(stHours === 12)
                            {
                                return -1;
                            }
                            else
                            {
                                return 1;         
                            } 
                        }
                        else if(stHours > enHours)
                        {
                            if(stHours === 12)
                            {
                                return 1;
                            }
                            else
                            {
                                return -1;         
                            }              
                        }
                    }

                    var minute = function(){
                        if(stMinutes === enMinutes)
                        {
                            return 0;
                        }else if(stMinutes < enMinutes)
                        {
                            return 1; 
                        }else if(stMinutes > enMinutes)
                        {
                            return -1;              
                        }
                    }

                    var timeDaySame = function(){
                        if(stTimeDay === enTimeDay)
                        {
                            return true;
                        }
                        else
                        {
                            return false;                          
                        }
                    }

                    var timeValid = function(){
                        if(timeDaySame()){

                            if(hour() === 0)
                            {

                            }
                            else if(hour() > 0)
                            {

                            }
                            else if(hour() < 0)
                            {

                            }

                        }else{

                        }
                    }

                    var currentDate = function(){
                        var sysDate = new Date();
                        var yr = sysDate.getFullYear();
                        var mth = sysDate.getMonth()+1;
                        var dy = sysDate.getDate();
                        var currentD = false;

                        if(date[0] >= yr
                            && date[1] >= mth
                            && date[2] >= dy)
                        {
                            currentD = true;
                        }

                        //console.log("date is before: "+currentD);

                        return currentD;
                    }

                    var setValid = function(){
                        
                        dateInput.invalid = false;
                        endInput.invalid = false;
                        startTimeInput.invalid = false;
                        endTimeInput.invalid = false;
                        self.replaceClass(icon, "fail", "pass");
                        datesValid = true;
                    }

                    if(currentDate())
                    {
                        if(year() === 0)//if start year is equal to end year
                        {
                            if(month() === 0)
                            {
                                if(day() === 0){
                                    //console.log("day is same");
                                    if(hour() === 0)
                                    {
                                        if(minute() === 0)
                                        {
                                            
                                            //console.log("end time must be later than start time.");
                                            self.assignClass(icon, "fail");
                                            startTimeInput.invalid = true;
                                        }
                                        else if(minute() < 0)
                                        {
                                            //console.log("start minutes is earlier than end minutes.");
                                            self.assignClass(icon, "fail");
                                            startTimeInput.invalid = true;
                                        }
                                        else if(minute() > 0)
                                        {
                                            //console.log("this should pass.");
                                            setValid();
                                        }
                                    }
                                    else if(hour() < 0)
                                    {
                                        //console.log("start hour cannot be before end hour.");
                                        self.assignClass(icon, "fail");
                                        startTimeInput.invalid = true;
                                    }
                                    else if(hour() > 0)
                                    {
                                        //console.log("this should pass.");
                                        setValid();
                                    }
                                }else if(day() < 0){
                                    //console.log("end day cannot be before end date.");
                                    self.assignClass(icon, "fail");
                                    dateInput.invalid = true;
                                    endInput.invalid = true;
                                }else if(day() > 0){
                                    //console.log("this should be ok for anytime.");
                                    setValid();
                                }else if(day() === 0){
                                    //console.log("check if start time is after end time.");
                                    if(hour() === 0)
                                    {
                                        //console.log("if hour is same, minutes must be later.");
                                        if(minute() === 0)
                                        {
                                            //console.log("start minutes, cant be same or less than end minutes.");
                                            self.assignClass(icon, "fail");
                                            startTimeInput.invalid = true;
                                        }
                                        else if(minute() > 0)
                                        {
                                            //console.log("this should be ok for anytime.");
                                            setValid();
                                        }
                                        else if(minute() < 0)
                                        {
                                            //console.log("start minutes, cant be same or less than end minutes.");
                                            self.assignClass(icon, "fail");
                                            startTimeInput.invalid = true;
                                        }

                                    }
                                    else if(hour() < 0)
                                    {
                                        //console.log("start hour cant be less than end hour.");
                                        self.assignClass(icon, "fail");
                                        startTimeInput.invalid = true;
                                    }
                                    if(hour() > 0)
                                    {
                                       // console.log("this should be ok for anytime.");
                                        setValid();
                                    }
                                }
                            }
                            else if(month() < 0)
                            {
                                //console.log("start month cannot be before end month.");
                                self.assignClass(icon, "fail");
                                dateInput.invalid = true;
                            }
                            else if(month() > 0)
                            {
                                //console.log("this should pass.");
                                setValid();
                            }

                        }
                        else if(year() < 0)//if start year is less than end year
                        {
                            //console.log("start year cannot be before end year.");
                            this.assignClass(icon, "fail");
                            dateInput.invalid = true;
                        }
                        else if(year() > 0)//if start year is more than end year
                        {
                            //console.log("this should pass.");
                            setValid();
                        }
                    }
                    else
                    {
                        //console.log("start date cannot be before current date.");
                        self.replaceClass(icon, "pass", "fail");
                        self.assignClass(icon, "fail");
                    }
                }
            }


            if(this.date !== this.end && this.startTime !== this.endTime)
            {

                var dateArr = this.date.split("/");
                var stTimeArr = this.startTime.split(":");
                var endArr = this.end.split("/");
                var enTimeArr = this.endTime.split(":");

                doValidate(dateArr, stTimeArr, endArr, enTimeArr);
                
            }
            else if(this.date !== this.end && this.startTime === this.endTime)
            {
                //console.log("time is not set");

                this.assignClass(icon, "fail");
                if(startTimeInput !== null && startTimeInput !== undefined
                    && endTimeInput !== null && endTimeInput !== undefined){
                    startTimeInput.invalid = true;
                    endTimeInput.invalid = true;
                }

            }else if(this.date === this.end && this.startTime !== this.endTime)
            {
                var dateArr = this.date.split("/");
                var stTimeArr = this.startTime.split(":");
                var endArr = this.end.split("/");
                var enTimeArr = this.endTime.split(":");

                doValidate(dateArr, stTimeArr, endArr, enTimeArr);
            }

        }

        this.dateTime = datesValid;
        //console.log(this.dateTime);
    },
    _storeEmails: function() {
        this.geoji.emailList = this.emailList;
    },
    _setVidTitle: function() {
        var vidTitle = this.getElem(this.ctrls.vidTitleInput);
        var selected = this.getElem(this.selectedMarker);

        if (this.geoji !== null && this.geoji !== undefined && this.vidTitle !== null && this.vidTitle !== undefined && this.selected !== null && this.selected !== undefined) {
            this.geoji[selected].title = this.vidTitle;
        }

    },
    _setVidId: function() {
        var vidId = this.getElem(this.ctrls.vidIdInput);
        var vidIcon = this.getElem(this.ctrls.vidIcon);
        var player = this.getElem(this.ctrls.youtubePlayer);
        var selected = this.getElem(this.selectedMarker);

        if (this.geoji !== null && this.geoji !== undefined && this.vidId !== null && this.vidId !== undefined && this.selected !== null && this.selected !== undefined) {
            this.geoji[selected].link = this.vidId;
            vidId.value = "https://youtu.be/" + this.vidId;
            vidicon.hidden = true;
        }

    },
    _setVidUrl: function() {
        var vidId = this.getElem(this.ctrls.vidIdInput);
        var vidIcon = this.getElem(this.ctrls.vidIcon);
        var player = this.getElem(this.ctrls.youtubePlayer);
        var selected = this.getElem(this.selectedMarker);

    },
    _mapSearch: function() {
        var addressList = this.getElem("addressList");

        if (addressList !== null && addressList !== undefined) {
            var child = addressList.children[0];
            var target = this.getElem(this.ctrls.targetMarker);

            target.longitude = this.mapResult[0].longitude;
            target.latitude = this.mapResult[0].latitude;
        }
    },
    _checkValid: function(){

        var title = this.getElem(this.ctrls.title);
        var start = this.getElem(this.ctrls.date);
        var end = this.getElem(this.ctrls.end);
        var startTime = this.getElem(this.ctrls.startTime);
        var endTime = this.getElem(this.ctrls.endTime);
        var cipherInput = this.getElem(this.ctrls.cipherInput);
        var geojiValid = false;
        var self = this;

        var titleValid = function(){
            var valid = false;
            if(self.title !== null && self.title !== undefined
                    && this.title !== "" && this.title !== " ")
            {
                var icon = self.getElem(self.ctrls.titleIcon);
                var container = self.getElem(self.ctrls.titleContainer);
                
                if(title.value !== "" && title.value !== " "){
                    valid = true;
                    container.invalid = false;
                    self.replaceClass(icon, "fail", "pass");
                }
            }

            return valid;
        }


        if(title !== null && title !== undefined
            && start !== null && start !== undefined
            && startTime !== null && startTime !== undefined
            && endTime !== null && endTime !== undefined
            && cipherInput !== null && cipherInput !== undefined
            && this.encrypted !== null && this.encrypted !== undefined)
        {
            var cIcon = self.getElem(self.ctrls.encryptIcon);
            self.replaceClass(cIcon, "pass", "");

            if(this.encrypted)
            {
                if(!cipherInput.invalid  && cipherInput.value !== "undefined")
                {
                    
                    self.replaceClass(cIcon, "fail", "pass");

                    if(titleValid() && this.dateTime)
                    {
                        geojiValid = true;
                    }
                }

            }
            else
            {
                if(titleValid() && this.dateTime)
                {
                    geojiValid = true;
                }
            }

            if(this.invalid !== null && this.invalid !== undefined)
            {
                this.invalid = !geojiValid;
            }

        }

    }
});
</script>
